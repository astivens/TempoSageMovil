@startuml TempoSage_Class_Diagram
!theme plain

' Configuración OPTIMIZADA - Relación de aspecto 2:3 (dimensiones físicas: 2200x3300px)
!define DPI 400
scale max 2200 width
scale max 3300 height

skinparam backgroundColor #FFFFFF
skinparam defaultFontSize 28
skinparam classFontSize 27
skinparam classAttributeFontSize 26
skinparam classMethodFontSize 26
skinparam packageFontSize 28
skinparam linetype ortho

' Colores específicos para cada capa
skinparam package {
    BackgroundColor #F8F9FA
    BorderColor #495057
    FontColor #212529
}

' Core Layer - Azul
skinparam class {
    BackgroundColor<<Core>> #E3F2FD
    BorderColor<<Core>> #1976D2
    FontColor<<Core>> #0D47A1
}

' Domain Layer - Verde
skinparam class {
    BackgroundColor<<Domain>> #E8F5E8
    BorderColor<<Domain>> #388E3C
    FontColor<<Domain>> #1B5E20
}

' Data Layer - Naranja
skinparam class {
    BackgroundColor<<Data>> #FFF3E0
    BorderColor<<Data>> #F57C00
    FontColor<<Data>> #E65100
}

' Presentation Layer - Púrpura
skinparam class {
    BackgroundColor<<Presentation>> #F3E5F5
    BorderColor<<Presentation>> #7B1FA2
    FontColor<<Presentation>> #4A148C
}

' Services Layer - Rojo
skinparam class {
    BackgroundColor<<Services>> #FFEBEE
    BorderColor<<Services>> #C62828
    FontColor<<Services>> #B71C1C
}

skinparam classArrowColor #495057
skinparam arrowColor #495057

' Configuración para mejor legibilidad
skinparam minClassWidth 140
skinparam maxClassWidth 180
skinparam classIconSize 0

title Diagrama de Clases - TempoSage\nArquitectura Limpia con Diferenciación Visual

' ===========================================
' CORE LAYER
' ===========================================
package "Core Layer" as core #E3F2FD {
    
    abstract class LocalStorage <<Core>> {
        +getBox<T>(): Future<Box<T>>
        +getAllData<T>(): Future<List<T>>
        +saveData<T>(): Future<void>
        +deleteData(): Future<void>
    }
    
    class ServiceLocator <<Core>> {
        -{static} _instance: ServiceLocator
        +{static} getInstance(): ServiceLocator
        +getActivityRepository(): ActivityRepository
        +getTimeBlockRepository(): TimeBlockRepository
        +getHabitRepository(): HabitRepository
    }
    
    class Logger <<Core>> {
        +{static} instance: Logger
        +i(String message, String? tag): void
        +e(String message, String? tag, dynamic error): void
        +d(String message, String? tag): void
    }
}

' ===========================================
' DOMAIN LAYER - Entities & Abstractions
' ===========================================
package "Domain Layer" as domain #E8F5E8 {
    
    ' Entities
    class Activity <<Domain>> {
        +id: String
        +name: String
        +date: DateTime
        +category: String
        +isCompleted: bool
    }
    
    class Habit <<Domain>> {
        +id: String
        +name: String
        +daysOfWeek: List<String>
        +category: String
        +time: String
        +isDone: bool
        +copyWith(): Habit
    }
    
    class TimeBlock <<Domain>> {
        +id: String
        +title: String
        +startTime: DateTime
        +endTime: DateTime
        +category: String
    }
    
    ' Repository Abstractions
    abstract class HabitRepository <<Domain>> {
        +getAllHabits(): Future<List<Habit>>
        +addHabit(Habit habit): Future<void>
        +updateHabit(Habit habit): Future<void>
        +deleteHabit(String id): Future<void>
    }
    
    abstract class ActivityRepository <<Domain>> {
        +getAllActivities(): Future<List<Activity>>
        +addActivity(Activity activity): Future<void>
        +updateActivity(Activity activity): Future<void>
        +deleteActivity(String id): Future<void>
    }
    
    ' Use Cases
    class GetHabitsUseCase <<Domain>> {
        -repository: HabitRepository
        +execute(): Future<List<Habit>>
    }
    
    class PredictProductivityUseCase <<Domain>> {
        -apiService: TempoSageApiService
        +execute(): Future<Map<String, dynamic>>
    }
    
    class HabitToTimeBlockService <<Domain>> {
        -timeBlockRepository: TimeBlockRepository
        +planificarBloques(): Future<int>
    }
}

' ===========================================
' DATA LAYER - Models & Implementations
' ===========================================
package "Data Layer" as data #FFF3E0 {
    
    ' Models
    class HabitModel <<Data>> {
        <<HiveType>>
        +id: String
        +title: String
        +description: String
        +daysOfWeek: List<String>
        +isCompleted: bool
        +copyWith(): HabitModel
        +toJson(): Map<String, dynamic>
        +toDomain(): Habit
    }
    
    class ActivityModel <<Data>> {
        <<freezed>>
        +id: String
        +title: String
        +category: String
        +startTime: DateTime
        +endTime: DateTime
        +isCompleted: bool
        +toggleCompletion(): ActivityModel
    }
    
    class TimeBlockModel <<Data>> {
        <<HiveType>>
        +id: String
        +title: String
        +startTime: DateTime
        +endTime: DateTime
        +category: String
        +isFocusTime: bool
        +isCompleted: bool
    }
    
    ' Repository Implementations
    class HabitRepositoryImpl <<Data>> {
        -{static} _boxName: String
        -_localStorage: LocalStorage
        +getAllHabits(): Future<List<Habit>>
        +addHabit(Habit habit): Future<void>
        +updateHabit(Habit habit): Future<void>
        +deleteHabit(String id): Future<void>
    }
    
    class TimeBlockRepository <<Data>> {
        -_localStorage: LocalStorage
        +getAllTimeBlocks(): Future<List<TimeBlock>>
        +addTimeBlock(TimeBlock block): Future<void>
        +updateTimeBlock(TimeBlock block): Future<void>
    }
}

' ===========================================
' PRESENTATION LAYER - Controllers & State
' ===========================================
package "Presentation Layer" as presentation #F3E5F5 {
    
    ' State Management
    class HabitState <<Presentation>> {
        <<freezed>>
        +isLoading: bool
        +habits: List<Habit>
        +error: String?
        +initial(): HabitState
        +loading(): HabitState
        +loaded(List<Habit> habits): HabitState
        +error(String message): HabitState
    }
    
    class HabitCubit <<Presentation>> {
        -repository: HabitRepository
        +getHabitsForToday(): Future<void>
        +completeHabit(String id): Future<void>
        +createHabit(Habit habit): Future<void>
    }
    
    class DashboardController <<Presentation>> {
        -_activityRepository: ActivityRepository
        -_habitRepository: HabitRepository
        -_isLoading: bool
        +refreshDashboard(): Future<void>
        +getTodayActivities(): List<Activity>
        +predictProductivity(): Future<void>
    }
}

' ===========================================
' SERVICES LAYER
' ===========================================
package "Services Layer" as services #FFEBEE {
    
    class RecommendationService <<Services>> {
        -_logger: Logger
        +getActivityRecommendations(): Future<List<Activity>>
        +getHabitRecommendations(): Future<List<Habit>>
        +analyzeUserPatterns(): Future<Map<String, dynamic>>
    }
    
    class TempoSageApiService <<Services>> {
        +predictProductivity(): Future<Map<String, dynamic>>
        +suggestOptimalTime(): Future<List<TimeBlock>>
        +analyzePatterns(): Future<Map<String, dynamic>>
    }
    
    class NotificationService <<Services>> {
        +scheduleNotification(String id, DateTime time, String message): Future<void>
        +cancelNotification(String id): Future<void>
        +cancelAllNotifications(): Future<void>
    }
}

' ===========================================
' RELACIONES - Notación UML Estándar
' ===========================================

' Core Layer - Dependency Injection
ServiceLocator --> HabitRepositoryImpl : creates
ServiceLocator --> TimeBlockRepository : creates
ServiceLocator --> TempoSageApiService : creates

' Domain to Data - Inheritance (Repository Pattern)
HabitRepository <|-- HabitRepositoryImpl : implements
ActivityRepository <|-- HabitRepositoryImpl : implements

' Domain to Data - Composition
HabitRepositoryImpl --> LocalStorage : uses
TimeBlockRepository --> LocalStorage : uses

' Domain Entities to Data Models - Transformation
HabitModel ..> Habit : transforms to
ActivityModel ..> Activity : transforms to
TimeBlockModel ..> TimeBlock : transforms to

' Use Cases - Dependency
GetHabitsUseCase --> HabitRepository : depends on
PredictProductivityUseCase --> TempoSageApiService : depends on
HabitToTimeBlockService --> TimeBlockRepository : depends on

' Presentation - Dependencies
HabitCubit --> HabitRepository : uses
HabitCubit --> HabitState : manages
DashboardController --> ActivityRepository : uses
DashboardController --> HabitRepository : uses
DashboardController --> PredictProductivityUseCase : uses

' Services - Dependencies
RecommendationService --> Logger : uses
HabitToTimeBlockService --> TimeBlockRepository : uses

' Data Layer - Model Usage
HabitRepositoryImpl --> HabitModel : uses
TimeBlockRepository --> TimeBlockModel : uses

' Inheritance - Flutter/Riverpod Patterns
HabitCubit --|> Cubit : extends
DashboardController --|> ChangeNotifier : extends
HabitModel --|> HiveObject : extends
TimeBlockModel --|> HiveObject : extends

note right of ServiceLocator
  Singleton para inyección
  de dependencias
end note

note right of HabitRepository
  Abstracción del dominio.
  Implementación en Data Layer
end note

note bottom of HabitCubit
  Estado gestionado con
  BLoC pattern (Cubit)
end note

@enduml
