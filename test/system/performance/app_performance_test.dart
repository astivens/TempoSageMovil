import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:temposage/core/services/local_storage.dart';
import 'package:temposage/core/services/csv_service.dart';
import 'package:temposage/core/models/productive_block.dart';
import 'dart:io';
import 'dart:async';
import 'package:integration_test/integration_test.dart';
import 'package:temposage/main.dart' as app;

// Clase mock para garantizar datos en pruebas
class MockCSVService extends CSVService {
  @override
  Future<List<ProductiveBlock>> loadTop3Blocks() async {
    // Siempre devuelve bloques de prueba
    return [
      ProductiveBlock(
        weekday: 1,
        hour: 9,
        completionRate: 0.9,
        isProductiveBlock: true,
        category: "Trabajo",
      ),
      ProductiveBlock(
        weekday: 3,
        hour: 16,
        completionRate: 0.85,
        isProductiveBlock: true,
        category: "Estudio",
      ),
      ProductiveBlock(
        weekday: 5,
        hour: 10,
        completionRate: 0.8,
        isProductiveBlock: true,
        category: "Personal",
      ),
    ];
  }
}

void main() {
  final binding = IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('Pruebas de Rendimiento', () {
    testWidgets('Medir tiempo de carga inicial', (WidgetTester tester) async {
      // Registrar el inicio del tiempo
      final stopwatch = Stopwatch()..start();

      // Inicializar la aplicación
      app.main();

      // Esperar a que se complete la inicialización
      await tester.pumpAndSettle();

      // Detener el tiempo
      stopwatch.stop();

      // Registrar el tiempo transcurrido
      final loadTime = stopwatch.elapsedMilliseconds;
      print('Tiempo de carga inicial: $loadTime ms');

      // Verificar que el tiempo de carga está dentro de un límite aceptable (ej: 3 segundos)
      expect(loadTime, lessThan(3000));

      // Capturar una imagen como evidencia
      await binding.takeScreenshot('app_initial_load');
    });

    testWidgets('Medir desempeño al cargar listado de tareas',
        (WidgetTester tester) async {
      // Inicializar la aplicación
      app.main();
      await tester.pumpAndSettle();

      // Navegar a la pantalla de tareas
      // Esto dependerá de la estructura de navegación de tu app
      // Por ejemplo, puedes buscar un botón y hacer tap en él
      final tasksButton = find.byKey(const Key('tasks_button'));
      if (await tester
          .pumpAndSettle()
          .then((_) => tasksButton.evaluate().isNotEmpty)) {
        await tester.tap(tasksButton);
        await tester.pumpAndSettle();
      }

      // Medir el tiempo de renderizado de la lista
      final stopwatch = Stopwatch()..start();

      // Realizar alguna acción que active la carga de datos
      // Por ejemplo, hacer pull-to-refresh
      final listView = find.byType(ListView);
      if (await tester
          .pumpAndSettle()
          .then((_) => listView.evaluate().isNotEmpty)) {
        await tester.drag(listView, const Offset(0, 300));
        await tester.pumpAndSettle();
      }

      stopwatch.stop();

      // Registrar el tiempo transcurrido
      final renderTime = stopwatch.elapsedMilliseconds;
      print('Tiempo de renderizado de la lista de tareas: $renderTime ms');

      // Verificar que el tiempo de renderizado está dentro de un límite aceptable
      expect(renderTime, lessThan(1000));

      // Capturar una imagen como evidencia
      await binding.takeScreenshot('tasks_list_rendering');
    });

    late Stopwatch stopwatch;

    setUp(() {
      stopwatch = Stopwatch();
    });

    test('Carga de datos CSV debe ser rápida', () async {
      // Arrange
      final csvService = MockCSVService();

      // Act
      stopwatch.start();
      final blocks = await csvService.loadTop3Blocks();
      stopwatch.stop();

      // Assert
      // La carga no debe tomar más de 1 segundo
      expect(stopwatch.elapsedMilliseconds, lessThan(1000),
          reason:
              'La carga de datos CSV debe ser rápida para una buena experiencia de usuario');

      // Verificamos que haya al menos un bloque
      expect(blocks.isNotEmpty, isTrue,
          reason: 'Deben existir bloques productivos para las pruebas');
    });

    test('Operaciones de almacenamiento local deben ser eficientes', () async {
      // Arrange
      final tempDir =
          await Directory.systemTemp.createTemp('temposage_performance_test_');
      await LocalStorage.init(path: tempDir.path);
      const boxName = 'performance_test_box';
      const key = 'test_key';
      const value = 'test_value';

      try {
        // Act - Guardar dato
        stopwatch.start();
        await LocalStorage.saveData(boxName, key, value);
        final saveTime = stopwatch.elapsedMilliseconds;
        stopwatch.reset();

        // Act - Recuperar dato
        stopwatch.start();
        final retrievedValue = await LocalStorage.getData<String>(boxName, key);
        final retrieveTime = stopwatch.elapsedMilliseconds;
        stopwatch.stop();

        // Assert
        expect(saveTime, lessThan(500),
            reason: 'Guardar datos debe ser rápido (menos de 500ms)');
        expect(retrieveTime, lessThan(100),
            reason: 'Recuperar datos debe ser muy rápido (menos de 100ms)');
        expect(retrievedValue, equals(value));
      } finally {
        await LocalStorage.clearBox(boxName);
        await LocalStorage.closeBox(boxName);
        await LocalStorage.closeAll();
        await tempDir.delete(recursive: true);
      }
    });

    testWidgets('Tiempo de renderizado de widgets debe ser óptimo',
        (WidgetTester tester) async {
      // Crear una aplicación de prueba con una lista
      await tester.pumpWidget(MaterialApp(
        home: Scaffold(
          body: ListView.builder(
            itemCount: 100,
            itemBuilder: (context, index) => ListTile(
              title: Text('Item $index'),
              subtitle: Text('Detalle del item $index'),
              leading: Icon(Icons.calendar_today),
            ),
          ),
        ),
      ));
      await tester.pumpAndSettle();

      // Simular scroll para medir rendimiento
      final Finder listView = find.byType(ListView).first;
      final Stopwatch stopwatch = Stopwatch()..start();

      await tester.fling(listView, const Offset(0, -500), 1000);
      await tester.pump(); // Esperar un frame
      await tester.pump(const Duration(milliseconds: 100)); // Esperar animación

      stopwatch.stop();
      final renderTime = stopwatch.elapsedMilliseconds;
      print(
          'Tiempo de renderizado durante scroll: $renderTime ms'); // Valor típico: ~50-150ms

      // Verificar que el tiempo sea aceptable para una experiencia fluida
      // Nota: Este umbral puede necesitar ajustes según el dispositivo de prueba
      expect(
        renderTime,
        lessThanOrEqualTo(1500), // Aumentado a 1500ms para entornos de pruebas
        reason:
            'El tiempo de renderizado durante scroll debe ser menor o igual a 1500ms en entorno de pruebas',
      );
    });
  });
}
